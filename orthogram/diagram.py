"""Provides the elements of a diagram."""

from typing import (
    Dict,
    Iterable,
    Iterator,
    List,
    Mapping,
    Optional,
    Sequence,
    Set,
    Tuple,
)

from .attributes import (
    AttributeMap,
    Attributes,
    DiagramAttributes,
    LinkAttributes,
    TerminalAttributes,
)

from .geometry import IntBounds, IntPoint, Orientation
from .util import log_info, log_warning

######################################################################

class RowDef:
    """Definition of a diagram row.

    Holds the information necessary to create a row of diagram cells.

    """

    def __init__(self, tags: Sequence[Optional[str]]):
        """Initialize with the given tags."""
        self._tags = tags

    @property
    def tags(self) -> Sequence[Optional[str]]:
        """Return the tags for the cells."""
        return list(self._tags)

######################################################################

class TerminalDef:
    """Definition of a terminal.

    Holds the information necessary to create a terminal.

    """

    def __init__(
            self,
            name: str,
            tags: Sequence[str] = (),
            **attrs: AttributeMap,
    ):
        """Initialize for a terminal with the given name."""
        self._name = name
        # Ensure each tag is used once.  Remove empty tags.  Preserve
        # order.
        uniseq = []
        for tag in tags:
            if tag not in uniseq:
                uniseq.append(tag)
        self._tags = uniseq
        self._attributes = attrs

    @property
    def name(self) -> str:
        """Name of the terminal."""
        return self._name

    @property
    def tags(self) -> Sequence[str]:
        """Tags used to look up cells.

        Ensures that each tag is unique.  Preservers the original
        order of the tags.

        """
        return list(self._tags)

    @property
    def attributes(self) -> AttributeMap:
        """The attributes to create the terminal with."""
        return self._attributes

######################################################################

class LinkDef:
    """Definition of a link between two terminals.

    Holds the information necessary to create a link.

    """

    def __init__(self, start: str, end: str, **attrs: AttributeMap):
        """Initialize given the names of two terminals."""
        self._start = start
        self._end = end
        self._attributes = attrs

    @property
    def start(self) -> str:
        """Name of the source terminal."""
        return self._start

    @property
    def end(self) -> str:
        """Name of the destination terminal."""
        return self._end

    @property
    def attributes(self) -> AttributeMap:
        """Attributes to create the link with."""
        return self._attributes

######################################################################

class DiagramDef:
    """Definition of a diagram.

    Holds the information necessary to create a diagram.

    """

    def __init__(self, **attrs: AttributeMap):
        """Initialize with the given diagram attributes.

        See DiagramAttributes for a list of available attributes.

        """
        self._attributes = Attributes(**attrs)
        self._auto_terminal_attributes = Attributes()
        self._row_defs: List[RowDef] = []
        self._terminal_defs: Dict[str, TerminalDef] = {}
        self._link_defs: List[LinkDef] = []

    @property
    def attributes(self) -> Attributes:
        """The attributes to create the diagram with."""
        return self._attributes

    @property
    def auto_terminal_attributes(self) -> Attributes:
        """Attributes for terminals generated automatically from tags."""
        return self._auto_terminal_attributes

    def set_auto_terminal_attributes(self, **attrs: AttributeMap) -> None:
        """Set the attributes of the autogenerated terminals."""
        self._auto_terminal_attributes = Attributes(**attrs)

    def add_row(self, tags: Sequence[Optional[str]]) -> None:
        """Add a row at the end of the diagram.

        The input is a sequence of strings used to tag the cells with.
        An empty string or None results in an untagged cell.  The
        length of the new row is equal to the number of tags (empty or
        not).

        """
        rdef = RowDef(tags)
        self._row_defs.append(rdef)

    def add_terminal(
            self,
            name: str,
            tags: Sequence[str] = (),
            **attrs: AttributeMap,
    ) -> None:
        """Add a new terminal to the diagram.

        The 'tags' argument is a list of cell tags.  The terminal will
        cover the cells matching the tags in addition to the cells
        tagged with the name of the terminal itself.

        See TerminalAttributes for a list of available attributes.

        Rejects the terminal with a warning if there is already a
        terminal registered with the same name.

        """
        tdefs = self._terminal_defs
        if name in tdefs:
            log_warning("Terminal '{}' already exists".format(name))
            return
        tdef = TerminalDef(name, tags, **attrs)
        tdefs[name] = tdef

    def add_links(
            self,
            start_names: Sequence[str],
            end_names: Sequence[str],
            **attrs: AttributeMap,
    ) -> None:
        """Create many links at once.

        If the number of start terminals is n and the number of end
        terminals in m, then the number of links created will be n*m
        (assuming all terminals exist.)  See add_link() for further
        information.

        """
        for start in start_names:
            for end in end_names:
                self.add_link(start, end, **attrs)

    def add_link(self, start: str, end: str, **attrs: AttributeMap) -> None:
        """Create a link between two terminals.

        You must supply the names of the start and end terminals.

        See LinkAttributes for a list of available attributes.

        """
        ldef = LinkDef(start, end, **attrs)
        self._link_defs.append(ldef)

    def row_defs(self) -> Iterator[RowDef]:
        """Return an iterator over the row definitions."""
        yield from self._row_defs

    def terminal_defs(self) -> Iterator[TerminalDef]:
        """Return an iterator over the terminal definitions."""
        yield from self._terminal_defs.values()

    def link_defs(self) -> Iterator[LinkDef]:
        """Return an iterator over the link definitions."""
        yield from self._link_defs

######################################################################

class DiagramCell:
    """Position in the diagram grid."""

    def __init__(self, point: IntPoint, tag: Optional[str] = None):
        """Initialize for the given point with an optional tag."""
        self._point = point
        # Empty string is not a tag.
        if not tag:
            tag = None
        self._tag = tag

    def __repr__(self) -> str:
        """Convert to string."""
        return "{}(i={},j={},tag={})".format(
            self.__class__.__name__,
            self._point.i,
            self._point.j,
            self._tag,
        )

    @property
    def point(self) -> IntPoint:
        """Position of the object in the grid."""
        return self._point

    @property
    def tag(self) -> Optional[str]:
        """Tag used to look up the cell."""
        return self._tag

######################################################################

class DiagramRow:
    """A row in the diagram."""

    def __init__(self, i: int, tags: Sequence[Optional[str]]):
        """Initialize the row."""
        self._i = i
        cells = []
        for j, tag in enumerate(tags):
            p = IntPoint(i=i, j=j)
            cell = DiagramCell(p, tag)
            cells.append(cell)
        self._cells = cells

    def __repr__(self) -> str:
        """Convert to string."""
        return "{}(i={},width={})".format(
            self.__class__.__name__,
            self._i,
            len(self._cells),
        )

    def __len__(self) -> int:
        """Return the number of cells."""
        return len(self._cells)

    def __iter__(self) -> Iterator[DiagramCell]:
        """Return an iterator over the cells."""
        yield from self._cells

    def expand(self, n: int) -> None:
        """Add cells at the end if the row is shorter than the given length."""
        cells = self._cells
        m = len(cells)
        i = self._i
        for j in range(m, n):
            p = IntPoint(i=i, j=j)
            cell = DiagramCell(p)
            cells.append(cell)

######################################################################

class DiagramGrid:
    """Contains the cells of the diagram."""

    def __init__(self) -> None:
        """Initialize an empty grid."""
        self._rows: List[DiagramRow] = []

    def __iter__(self) -> Iterator[DiagramRow]:
        """Return an iterator over the rows."""
        yield from self._rows

    @property
    def height(self) -> int:
        """Number of rows."""
        return len(self._rows)

    @property
    def width(self) -> int:
        """Number of columns."""
        rows = self._rows
        if not rows:
            return 0
        else:
            return len(rows[0])

    def add_row(self, tags: Sequence[Optional[str]]) -> None:
        """Add a row of cells to the grid."""
        i = len(self._rows)
        row = DiagramRow(i, tags)
        rows = self._rows
        rows.append(row)
        # Adjust the width of the rows.
        new_width = max(self.width, len(row))
        for row in rows:
            row.expand(new_width)

    def cells_containing(self, tags: Iterable[str]) -> Iterator[DiagramCell]:
        """Return an iterator over the cells that contain the given tags.

        It calculates the minimum rectangular area that contains all
        the cells with the given tags.  The iterator iterates over all
        the cells in the rectangular area (i.e. not only the cells
        with the given tags.)  It yields the cells in the order that
        they are stored in the grid, i.e. the order of the tags is
        irrelevant.

        """
        points = []
        for cell in self._cells_tagged(tags):
            points.append(cell.point)
        bounds = IntBounds.containing(points)
        if bounds:
            yield from self._cells_covering(bounds)

    def _cells_tagged(self, tags: Iterable[str]) -> Iterator[DiagramCell]:
        """Return an iterator over the cells with the given tags.

        The iterator yields the cells in the order that they are
        stored in the grid.  The order of the tags is irrelevant.

        """
        tag_set = set(tags)
        for cell in self._cells():
            tag = cell.tag
            if tag and tag in tag_set:
                yield cell

    def _cells_covering(self, bounds: IntBounds) -> Iterator[DiagramCell]:
        """Return an iterator over the cells covering the bounding box.

        The iterator yields the cells in the order that they are
        stored in the grid.

        """
        for row in self._rows:
            for cell in row:
                p = cell.point
                if (p.i >= bounds.imin and p.i <= bounds.imax and
                    p.j >= bounds.jmin and p.j <= bounds.jmax):
                    yield cell

    def _cells(self) -> Iterator[DiagramCell]:
        """Return an iterator over the cells.

        The iterator yields the cells in the order that they are
        stored in the grid.

        """
        for row in self._rows:
            yield from row

    def tag_set(self) -> Set[str]:
        """Return all the tags from the cells in no particular order."""
        tags = set()
        for cell in self._cells():
            tag = cell.tag
            if tag:
                tags.add(tag)
        return tags

######################################################################

class Node:
    """Endpoint of a link on a terminal."""

    def __init__(self, cell: DiagramCell):
        """Initialize and place in the given cell."""
        self._cell = cell
        # By default, links can pass through the node.  This can be
        # changed by connecting a terminal to the node.
        self._pass_through = True

    @property
    def pass_through(self) -> bool:
        """Can links pass through this node?"""
        return self._pass_through

    @pass_through.setter
    def pass_through(self, value: bool) -> None:
        self._pass_through = value

    @property
    def point(self) -> IntPoint:
        """Position of the node in the diagram grid."""
        return self._cell.point

######################################################################

class Terminal:
    """Links terminate here."""

    def __init__(self, name: str, **attrs: AttributeMap):
        """Initialize the terminal (with optional attributes)."""
        self._name = name
        self._attributes = TerminalAttributes(**attrs)
        self._nodes: List[Node] = []
        self._bounds: Optional[IntBounds] = None

    def __repr__(self) -> str:
        """Convert to string."""
        return "{}({})".format(
            self.__class__.__name__,
            self._name,
        )

    @property
    def name(self) -> str:
        """A name that identifies the terminal."""
        return self._name

    @property
    def attributes(self) -> TerminalAttributes:
        """Attributes attached to the terminal."""
        return self._attributes

    @property
    def bounds(self) -> Optional[IntBounds]:
        """Return the bounding box of the terminal in the diagram grid."""
        b = self._bounds
        if b:
            return b.copy()
        else:
            return None

    def label(self) -> str:
        """Return a label to draw on the terminal in the diagram."""
        label = self._attributes.label
        # Compare against None - the empty string is a valid label.
        if label is None:
            return self._name
        else:
            return label

    def add_node(self, node: Node) -> None:
        """Associate the terminal with the node.

        It preserves the order of the nodes and ensures that no node
        is added more than once.

        """
        nodes = self._nodes
        if node not in nodes:
            nodes.append(node)
        # Recalculate the bounding box.
        self._update_bounds()

    def _update_bounds(self) -> None:
        """Update the bounding box covered by the nodes."""
        points = []
        for node in self._nodes:
            points.append(node.point)
        self._bounds = IntBounds.containing(points)

    def nodes(self) -> Iterator[Node]:
        """Return an iterator over the nodes.

        The iterator yields the nodes in the order they are stored in
        the object.

        """
        yield from self._nodes

    def outer_nodes(self) -> Iterator[Node]:
        """Return an iterator over the nodes at the sides of the terminal.

        The iterator yields the nodes in the order they are stored in
        the object.  These nodes are supposed to be used for
        connections.

        """
        bounds = self._bounds
        if not bounds:
            return
        imin, jmin, imax, jmax = bounds
        for node in self.nodes():
            i, j = node.point
            if i == imin or i == imax or j == jmin or j == jmax:
                yield node

    def is_placed(self) -> bool:
        """True it the terminal has at least one node."""
        return len(self._nodes) > 0

    def overlaps_with(self, other: 'Terminal') -> bool:
        """True if the two terminals have common nodes."""
        nodes_1 = set(self.nodes())
        nodes_2 = set(other.nodes())
        if nodes_1.intersection(nodes_2):
            return True
        else:
            return False

######################################################################

class Link:
    """A link between two terminals in the diagram."""

    def __init__(self, start: Terminal, end: Terminal, **attrs: AttributeMap):
        """Initialize a link between the given terminals."""
        self._start = start
        self._end = end
        self._attributes = LinkAttributes(**attrs)

    def __repr__(self) -> str:
        """Convert to string."""
        return "{}({}->{})".format(
            self.__class__.__name__,
            self._start.name,
            self._end.name,
        )

    @property
    def start(self) -> Terminal:
        """Source terminal of the link."""
        return self._start

    @property
    def end(self) -> Terminal:
        """Destination terminal of the link."""
        return self._end

    @property
    def attributes(self) -> LinkAttributes:
        """Attributes attached to the link."""
        return self._attributes

######################################################################

class Diagram:
    """Container for the terminals and links of the diagram."""

    def __init__(self, ddef: DiagramDef):
        """Initialize from the definition."""
        self._attributes = DiagramAttributes(**ddef.attributes)
        self._grid = self._make_grid(ddef)
        self._terminals: Dict[str, Terminal] = {}
        self._nodes_to_terminals: Dict[Node, List[Terminal]] = {}
        self._points_to_nodes: Dict[IntPoint, Node] = {}
        self._init_terminals(ddef)
        self._links: List[Link] = []
        self._init_links(ddef)

    @staticmethod
    def _make_grid(ddef: DiagramDef) -> DiagramGrid:
        """Create the grid from the diagram definition."""
        grid = DiagramGrid()
        for row_def in ddef.row_defs():
            grid.add_row(row_def.tags)
        return grid

    def _init_terminals(self, ddef: DiagramDef) -> None:
        """Create the terminals from the definition."""
        terminals = self._terminals
        terminals.clear()
        nodes_to_terminals = self._nodes_to_terminals
        nodes_to_terminals.clear()
        points_to_nodes = self._points_to_nodes
        points_to_nodes.clear()
        self._make_defined_terminals(ddef)
        self._make_leftover_terminals(ddef)

    def _make_defined_terminals(self, ddef: DiagramDef) -> None:
        """Create the terminals defined in the diagram definition."""
        self._make_terminals(ddef.terminal_defs())

    def _make_leftover_terminals(self, ddef: DiagramDef) -> None:
        """Create terminals from leftover tags."""
        attrs = ddef.auto_terminal_attributes
        tags = sorted(self._leftover_tags(ddef))
        tdefs = []
        for tag in tags:
            tdef = TerminalDef(tag, [], **attrs)
            tdefs.append(tdef)
        self._make_terminals(tdefs)

    def _leftover_tags(self, ddef: DiagramDef) -> Set[str]:
        """Cell tags that have not been used for terminals."""
        tags = self._grid.tag_set()
        for tdef in ddef.terminal_defs():
            term_tags = set(tdef.tags)
            term_tags.add(tdef.name)
            for tag in term_tags:
                if tag in tags:
                    tags.remove(tag)
        return tags

    def _make_terminals(self, tdefs: Iterable[TerminalDef]) -> None:
        """Use the terminal definitions to create terminals."""
        terminals = self._terminals
        nodes_to_terminals = self._nodes_to_terminals
        points_to_nodes = self._points_to_nodes
        for tdef in tdefs:
            name = tdef.name
            terminal = Terminal(name, **tdef.attributes)
            terminals[name] = terminal
            hard = not terminal.attributes.pass_through
            tags = list(tdef.tags)
            # Cells tagged with the name of the terminal come last
            # (unless the name is already in the tags).
            tags.append(name)
            # Find or create the nodes.
            for cell in self._cells_containing(tags):
                p = cell.point
                node = points_to_nodes.get(p)
                if not node:
                    node = Node(cell)
                    points_to_nodes[p] = node
                # Make node blocking if the configuration of a
                # terminal says so.
                if hard:
                    node.pass_through = False
                terminal.add_node(node)
                if node not in nodes_to_terminals:
                    nodes_to_terminals[node] = []
                nodes_to_terminals[node].append(terminal)

    def _cells_containing(self, tags: Sequence[str]) -> Iterator[DiagramCell]:
        """Return an iterator over the cells that contain the given tags.

        This iterator yields the cells in the order specified by the
        sequence of tags.

        """
        # Calculate the order of each tag.
        order = 0
        tag_orders: Dict[str, int] = {}
        for tag in tags:
            if tag and tag not in tag_orders:
                tag_orders[tag] = order
                order += 1
        # Create groups for all the orders plus one for the rest of
        # the cells.
        cells_by_order: List[List[DiagramCell]] = []
        for _ in range(len(tag_orders) + 1):
            cells_by_order.append([])
        for cell in self._grid.cells_containing(tags):
            cell_tag = cell.tag
            if cell_tag in tag_orders:
                order = tag_orders[cell_tag]
            else:
                order = -1
            cells_by_order[order].append(cell)
        for cells in cells_by_order:
            yield from cells

    def _init_links(self, ddef: DiagramDef) -> None:
        """Create the links from the definition."""
        links = self._links
        links.clear()
        for ldef in ddef.link_defs():
            link = self._make_link(ldef)
            if link:
                links.append(link)

    def _make_link(self, ldef: LinkDef) -> Optional[Link]:
        """Create a link from a link definition."""
        # Ensure that the two terminals have been registered and
        # placed.
        start = self._terminal(ldef.start)
        end = self._terminal(ldef.end)
        if not (start and end):
            return None
        ok = True
        for terminal in (start, end):
            if not terminal.is_placed():
                log_warning("Terminal '{}' is not placed".format(terminal.name))
                ok = False
        if not ok:
            return None
        # Cannot create link between overlapping terminals.
        if start.overlaps_with(end):
            temp = "Terminals '{}' and '{}' overlap, link rejected"
            log_warning(temp.format(start.name, end.name))
            return None
        # Everything seems OK, let's make the connection.
        link = Link(start, end, **ldef.attributes)
        return link

    def _terminal(self, name: str) -> Optional[Terminal]:
        """Retrieve a terminal by name."""
        terminal = self._terminals.get(name)
        if not terminal:
            log_warning("Terminal '{}' does not exist".format(name))
        return terminal

    @property
    def grid(self) -> DiagramGrid:
        """The grid that contains the terminals."""
        return self._grid

    @property
    def attributes(self) -> DiagramAttributes:
        """Attributes attached to the diagram."""
        return self._attributes

    def links(self) -> Iterator[Link]:
        """Return an iterator over the links."""
        yield from self._links

    def node_terminals(self, node: Node) -> Iterator[Terminal]:
        """Iterate over the terminals connected to a node."""
        yield from self._nodes_to_terminals[node]

    def nodes_and_terminals(self) -> Iterator[Tuple[Node, Set[Terminal]]]:
        """Return an iterator over the nodes and the terminals on it."""
        for node, terminals in self._nodes_to_terminals.items():
            yield node, set(terminals)

    def _pretty_print(self) -> None:
        """Print the diagram for debugging purposes."""
        print("Terminals:")
        for terminal in self._terminals.values():
            print("\t{}".format(terminal))
        print("Links:")
        for link in self._links:
            print("\t{}".format(link))
        print("Rows:")
        for row in self._grid:
            print("\t{}:".format(row))
            for cell in row:
                print("\t\t{}".format(cell))
